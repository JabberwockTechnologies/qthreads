.TH qthread_readFE 3 "NOVEMBER 2006" libqthread "libqthread"
.SH NAME
qthread_readFE \- waits for the source to be full, then copies it
.SH SYNOPSIS
.B #include <qthread/qthread.h>

.I void
.br
\fBqthread_readFE\fR(qthread_t *\fIme\fR, void *\fIdest\fR, void *\fIsrc\fR);
.SH DESCRIPTION
This function waits for memory to become full, and then empties it. When memory
becomes full, only one thread blocked like this will be awoken. Data is read
from \fIsrc\fR and stored in \fIdest\fR.
.PP
The semantics of readFE are:
.RS
.PP
1 - \fIsrc\fR's FEB state must be "full"
.br
2 - data is copied from \fIsrc\fR to \fIdest\fR
.br
3 - \fIsrc\fR's FEB state gets changed from "full" to "empty"
.RE
.PP
This function takes a qthread_t pointer as an argument (\fIme\fR), which is
supposed to point to the qthread_t relating to the currently executing qthread.
If this is called from somewhere other than a qthread, use NULL for the
\fIme\fR argument. If the qthread_t pointer has been lost, it can be reclaimed
using \fBqthread_self\fR() (which, conveniently, returns NULL if run from a
non-qthread).
.SH WARNING
This, and all other FEB-related functions currently operate exclusively on
aligned data. This is to simulate the behavior of the MTA as closely as
possible. If the library was compiled for a 32-bit architecture, it will
require 4-byte alignment and reads/writes will operate on four bytes at a time;
if the library was compiled for a 64-bit architecture, it will require 8-byte
alignment and reads/writes will operate on eight bytes at a time.
.SH "SEE ALSO"
.BR qthread_empty (3),
.BR qthread_fill (3),
.BR qthread_writeFE (3),
.BR qthread_writeF (3),
.BR qthread_readFF (3),
.BR qthread_lock (3),
.BR qthread_unlock (3)
