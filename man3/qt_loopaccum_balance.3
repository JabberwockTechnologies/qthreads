.TH qt_loop_balance 3 "JUNE 2007" libqthread "libqthread"
.SH NAME
\fBqt_loopaccum_balance\fR, \fBqt_loopaccum_balance_future\fR \- a slightly
intelligent implementation of a threaded loop that returns values
.SH SYNOPSIS
.B #include <qthread/qloop.h>

.I void
.br
\fBqt_loopaccum_balance\fR(const size_t \fIstart\fR,
const size_t \fIstop\fR,
.ti +21
const size_t \fIsize\fR,
void *\fIout\fR,
.ti +21
const qt_loopr_f \fIfunc\fR,
void *\fIargptr\fR,
.ti +21
const qt_accum_f \fIacc\fR);
.PP
.I void
.br
\fBqt_loopaccum_balance_future\fR(const size_t \fIstart\fR,
const size_t \fIstop\fR,
.ti +28
const size_t \fIsize\fR,
void *\fIout\fR,
.ti +28
const qt_loopr_f \fIfunc\fR,
void *\fIargptr\fR,
.ti +28
const qt_accum_f \fIacc\fR);
.SH DESCRIPTION
This function provides a simple C implementation of a threaded accumulating
loop. Rather than using a predictable number of threads, however, the number of
threads generated depends directly upon the number of shepherds available. The
difference between \fBqt_loopaccum_balance\fR and
\fBqt_loopaccum_balance_future\fR is that the former uses qthreads and the
latter uses futures. The idea with the accumulation is that they can be used to
collect values from multiple threads. For example, if there is a running tally
of outputs, or if the maximum return value must be retained, this is a way to
do it.
.PP
These function can be thought of as akin to (but not replicating exactly) the
following code:
.RS
.PP
unsigned int i;
.br
for (i = \fIstart\fR; i < \fIstop\fR; i ++) {
.RS
.br
\fIfunc\fR(NULL, \fIargptr\fR, \fIret\fR);
.br
\fIacc\fR(tmp, \fIret\fR);
.RE
.br
}
.RE
.PP
One qthread (or future) is spawned for each shepherd. The set of values of
\fIi\fR (iterations) is divided evenly among the shepherds, and each qthread
(or future) is assigned a set of iterations to perform.
.PP
The \fIfunc\fR argument must be a function pointer with a \fBqt_loopr_f\fR
prototype. Note that this is NOT the same as \fBqt_loop_f\fR functions, as it
has the extra \fIret\fR argument. Its basic code structure is expected to look
like this:
.RS
.PP
void \fBfunc\fR(qthread_t *\fIme\fR,
const size_t \fIstartat\fR,
.ti +10
const size_t \fIstopat\fR,
void *\fIarg\fR,
void *\fIret\fR)
.br
{
.RS
.br
for (unsigned int i = startat; i < stopat; i++) {
.RS
.br
/* do work */
.RE
.br
}
.RE
.br
}
.RE
.PP
The arguments \fIstartat\fR and \fIstopat\fR are determined by the library, and
tell the function what range of \fIi\fR values (iterations) it is responsible
for. \fBqt_loop_balance\fR and \fBqt_loop_balance_future\fR will not return
until all of the qthreads (or futures) it spawned have exited.
.PP
The \fIacc\fR argument must be a function pointer with a \fBqt_accum_f\fR
prototype. This prototype looks like this:
.RS
.PP
void \fBacc\fR (void *\fIa\fR, void *\fIb\fR);
.RE
.PP
The accumulating value is stored in the memory pointed to by the \fIa\fR
argument, and a new value is passed in via the \fIb\fR argument. Keep in mind
that when there is only a single shepherd, this function is never called, as
the entire set of iterations will be given to a single instance of \fIfunc\fR
to perform. Because of this, and because there is no guarantee as to how the
iterations will be divided, \fIfunc\fR is expected to perform essentially the
same accumulation operation that \fIacc\fR does. There is also no guarantee as
to what order things will be accumulated in, so the operation needs to be
commutative if all runs of the program are expected to return the same result.
.PP
The result of the accumulations (\fIacc\fR), if any, of the output (\fIret\fR)
of \fIfunc\fR will be stored in the memory pointed to by \fIout\fR. This memory
is assumed to be at least \fIsize\fR bytes, and \fIsize\fR bytes will be used
for storage of all \fIret\fR arguments to \fIfunc\fR calls.
.SH EXAMPLE
Since this is a bit complicated a simple example may be useful. The example is
the \fBqt_double_sum\fR function in the library; for simplicity's sake, the
\fIcheckfeb\fR option has been removed from this example. This function is
extremely simple:
.PP
double \fBqt_double_sum\fR (double *\fIarray\fR,
.ti +22
size_t \fIlength\fR)
.br
{
.RS
double ret;
.br
\fBqt_loopaccum_balance_future\fR(0,
\fIlength\fR,
sizeof(double),
.ti +28
&ret,
\fBqtds_worker\fR,
\fIarray\fR,
.ti +28
\fBqtds_acc\fR);
.br
return ret;
.RE
}
.PP
There are two function arguments to the \fBqt_loopaccum_balance_future\fR call, \fBqtds_worker\fR (as the \fIfunc\fR argument) and \fBqtds_acc\fR (as the \fIacc\fR or "accumulator" argument). \fBqtds_acc\fR is extremely simple:
.PP
static void \fBqtds_acc\fR (void *\fIa\fR, void *\fIb\fR)
.br
{
.RS
*(double*)\fIa\fR += *(double*)\fIb\fR;
.RE
}
.PP
The \fBqtds_worker\fR function does the real work of adding up the numbers:
.PP
static void \fBqtds_worker\fR (qthread_t *\fIme\fR,
const size_t \fIstartat\fR,
.ti +25
const size_t \fIstopat\fR,
void *\fIarray\fR,
void *\fIret\fR)
.br
{
.RS
size_t i;
.br
double sum = (double *)\fIarray\fR[\fIstartat\fR];
.br
for (i = \fIstartat\fR + 1; i < \fIstopat\fR; i++) {
.RS
sum += (double *)\fIarray\fR[i];
.RE
}
.br
*(double *)ret = acc;
.RE
}
.SH SEE ALSO
.BR qt_loop (3),
.BR qt_loop_future (3),
.BR qt_loop_balance (3),
.BR qt_loop_balance_future (3)
