.TH qt_double_min 3 "JUNE 2007" libqthread "libqthread"
.SH NAME
\fBqt_double_min\fR, \fBqt_uint_min\fR, \fBqt_int_min\fR \- find the
minimum value within an array in parallel
.SH SYNOPSIS
.B #include <qthread/qloop.h>

.I double
.br
\fBqt_double_min\fR(double *\fIarray\fR, size_t \fIlength\fR, int \fIcheckfeb\fR);
.PP
.I unsigned int
.br
\fBqt_uint_min\fR(unsigned int *\fIarray\fR, size_t \fIlength\fR, int
\fIcheckfeb\fR);
.PP
.I int
.br
\fBqt_int_min\fR(int *\fIarray\fR, size_t \fIlength\fR, int \fIcheckfeb\fR);
.SH DESCRIPTION
These functions take as input an \fIarray\fR of \fIlength\fR numbers and will
return the minimum value within those numbers. This value is computed in
parallel by dividing the iterations evenly among the shepherds, using futures
to restrict the parallelism to the available limits.
.PP
If \fIcheckfeb\fR is non-zero, these functions will wait for the entries in the
array to be full before comparing them. They \fBDO NOT\fR check whether the
array entries are properly aligned.
.SH RETURN VALUE
The minimum value of the first \fIlength\fR entries of \fIarray\fR.
.SH SEE ALSO
.BR qt_double_prod (3),
.BR qt_double_sum (3),
.BR qt_double_max (3),
.BR qt_uint_prod (3),
.BR qt_uint_sum (3),
.BR qt_uint_max (3),
.BR qt_int_prod (3),
.BR qt_int_sum (3),
.BR qt_int_max (3),
.BR qt_loop (3),
.BR qt_loop_future (3),
.BR qt_loop_balance (3),
.BR qt_loop_balance_future (3),
.BR qt_loopaccum_balance (3),
.BR qt_loopaccum_balance_future (3)
