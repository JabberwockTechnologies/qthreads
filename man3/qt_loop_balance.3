.TH qt_loop_balance 3 "JUNE 2007" libqthread "libqthread"
.SH NAME
\fBqt_loop_balance\fR, \fBqt_loop_balance_future\fR \- a slightly intelligent
implementation of a threaded loop
.SH SYNOPSIS
.B #include <qthread/qloop.h>

.I void
.br
\fBqt_loop_balance\fR(const size_t \fIstart\fR,
const size_t \fIstop\fR,
.ti +16
const qt_loop_f \fIfunc\fR,
void *\fIargptr\fR);
.PP
.I void
.br
\fBqt_loop_balance_future\fR(const size_t \fIstart\fR,
const size_t \fIstop\fR,
.ti +23
const qt_loop_f \fIfunc\fR,
void *\fIargptr\fR);
.SH DESCRIPTION
This function provides a simple C implementation of a threaded loop. Rather than using a predictable number of threads, however, the number of threads generated depends directly upon the number of shepherds available. The difference between \fBqt_loop_balance\fR and \fBqt_loop_balance_future\fR is that the former uses qthreads and the latter uses futures.
.PP
These function can be thought of as akin to the following code:
.RS
.PP
unsigned int i;
.br
for (i = \fIstart\fR; i < \fIstop\fR; i ++) {
.RS
\fIfunc\fR(NULL, \fIargptr\fR);
.RE
}
.RE
.PP
One qthread (or future) is spawned for each shepherd. The set of values of \fIi\fR (iterations) is divided evenly among the shepherds, and each qthread (or future) is assigned a set of iterations to perform.
.PP
The \fIfunc\fR argument must be a function pointer with a \fBqt_loop_f\fR prototype. Its basic code structure is expected to look like this:
.RS
.PP
void \fIfunc\fR(qthread_t *me, const size_t startat, const size_t stopat, void *\fIarg\fR)
.br
{
.RS
for (unsigned int i = startat; i < stopat; i++) {
.RS
/* do work */
.RE
}
.RE
}
.RE
.PP
The arguments \fIstartat\fR and \fIstopat\fR are determined by the library, and
tell the function what range of \fIi\fR values (iterations) it is responsible
for. \fBqt_loop_balance\fR and \fBqt_loop_balance_future\fR will not
return until all of the qthreads (or futures) it spawned have exited.
.SH SEE ALSO
.BR qt_loop (3),
.BR qt_loop_future (3),
.BR qt_loopaccum_balance (3),
.BR qt_loopaccum_balance_future (3)
