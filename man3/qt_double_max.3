.TH qt_double_max 3 "JUNE 2007" libqthread "libqthread"
.SH NAME
\fBqt_double_max\fR, \fBqt_uint_max\fR, \fBqt_int_max\fR \- find the
maximum value within an array in parallel
.SH SYNOPSIS
.B #include <qthread/qloop.h>

.I double
.br
\fBqt_double_max\fR(double *\fIarray\fR, size_t \fIlength\fR, int
\fIcheckfeb\fR);
.PP
.I unsigned int
.br
\fBqt_uint_max\fR(unsigned int *\fIarray\fR, size_t \fIlength\fR, int
\fIcheckfeb\fR);
.PP
.I int
.br
\fBqt_int_max\fR(int *\fIarray\fR, size_t \fIlength\fR, int \fIcheckfeb\fR);
.SH DESCRIPTION
These functions take as input an \fIarray\fR of \fIlength\fR numbers and will
return the maximum value within those numbers. This value is computed in
parallel by dividing the possible values up among the shepherds evenly, using
futures to restrict the parallelism to the available limits.
.PP
If \fIcheckfeb\fR is non-zero, these functions will wait for the entries in the
array to be full before comparing them. They \fBDO NOT\fR check whether the
array entries are properly aligned.
.SH RETURN VALUE
The maximum value of the first \fIlength\fR entries of \fIarray\fR.
.SH SEE ALSO
.BR qt_double_prod (3),
.BR qt_double_sum (3),
.BR qt_double_min (3),
.BR qt_uint_prod (3),
.BR qt_uint_sum (3),
.BR qt_uint_min (3),
.BR qt_int_prod (3),
.BR qt_int_sum (3),
.BR qt_int_min (3),
.BR qt_loop (3),
.BR qt_loop_future (3),
.BR qt_loop_balance (3),
.BR qt_loop_balance_future (3),
.BR qt_loopaccum_balance (3),
.BR qt_loopaccum_balance_future (3)
