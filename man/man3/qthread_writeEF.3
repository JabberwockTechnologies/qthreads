.TH qthread_writeEF 3 "NOVEMBER 2006" libqthread "libqthread"
.SH NAME
\fBqthread_writeEF\fR, \fBqthread_writeEF_const\fR \- waits for the dest to be empty, then fills it
.SH SYNOPSIS
.B #include <qthread/qthread.h>

.I int
.br
\fBqthread_writeEF\fR(qthread_t *\fIme\fR, void *\fIdest\fR, const void *\fIsrc\fR);
.PP
.I int
.br
\fBqthread_writeEF_const\fR(qthread_t *\fIme\fR, void *\fIdest\fR, const aligned_t \fIsrc\fR);
.SH DESCRIPTION
These functions wait for memory to become empty, and then fill it. When memory
becomes empty, only one thread blocked like this will be awoken. Data is read
from \fIsrc\fR and written to \fIdest\fR.
.PP
The semantics of writeEF are:
.RS
.PP
1 - \fIdest\fR's FEB state must be "empty"
.br
2 - data is copied from \fIsrc\fR to \fIdest\fR
.br
3 - \fIdest\fR's FEB state gets changed from "empty" to "full"
.RE
.PP
This function takes a qthread_t pointer as an argument (\fIme\fR), which is
supposed to point to the qthread_t relating to the currently executing qthread.
If \fIme\fR is NULL, the current qthread will be discovered using
\fBqthread_self\fR().
.SH WARNING
This, and all other FEB-related functions currently operate exclusively on
aligned data. This is to simulate the behavior of the MTA as closely as
possible. If the library was compiled for a 32-bit architecture, it will
require 4-byte alignment and reads/writes will operate on four bytes at a time;
if the library was compiled for a 64-bit architecture, it will require 8-byte
alignment and reads/writes will operate on eight bytes at a time.
.SH RETURN VALUE
On success, the memory address \fIdest\fR is marked full, the address
\fIdest\fR is filled with the contents of \fIsrc\fR and 0 is returned. On
error, a non-zero error code is returned.
.SH ERRORS
.TP 12
ENOMEM
Not enough memory could be allocated for bookkeeping structures.
.SH "SEE ALSO"
.BR qthread_empty (3),
.BR qthread_fill (3),
.BR qthread_writeF (3),
.BR qthread_readFF (3),
.BR qthread_readFE (3),
.BR qthread_lock (3),
.BR qthread_unlock (3)
