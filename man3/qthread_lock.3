.TH qthread_lock/unlock 3 "NOVEMBER 2006" libqthread "libqthread"
.SH NAME
\fBqthread_lock\fR, \fBqthread_unlock\fR \- lock or unlock an address
.SH SYNOPSIS
.B #include <qthread/qthread.h>

.I int
.br
\fBqthread_lock\fR(qthread_t *\fIme\fR, void *\fIaddr\fR);
.PP
.I int
.br
\fBqthread_unlock\fR(qthread_t *\fIme\fR, void *\fIaddr\fR);
.SH DESCRIPTION
These functions are designed to implement FEB-like locking and unlocking that
behaves much more like a mutex.
.PP
These are atomic and functional, but do not have the same semantics as full FEB
locking/unlocking (namely, unlocking cannot block), however because of this,
they have lower overhead.
.PP
This function takes a qthread_t pointer as an argument (\fIme\fR), which is
supposed to point to the qthread_t relating to the currently executing qthread.
If this is called from somewhere other than a qthread, use NULL for the
\fIme\fR argument. If the qthread_t pointer has been lost, it can be reclaimed
using \fBqthread_self\fR() (which, conveniently, returns NULL if run from a
non-qthread).
.SH RETURN VALUE
On success, the memory address \fIaddr\fR is marked locked or unlocked
appropriately and 0 is returned. If unlocking an address that is already
unlocked, QTHREAD_REDUNDANT will be returned. On error, a non-zero error code
is returned.
.SH ERRORS
.TP 12
ENOMEM
Not enough memory could be allocated for bookkeeping structures.
.SH "SEE ALSO"
.BR qthread_empty (3),
.BR qthread_fill (3),
.BR qthread_writeFE (3),
.BR qthread_writeF (3),
.BR qthread_readFF (3),
.BR qthread_readFE (3)
