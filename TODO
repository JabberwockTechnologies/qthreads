These are ideas for things to do (in no particular order):

 1. Use LockBox mutexes on BlueGene/P

 2. Mass thread-kill (e.g. eurekas)

 3. Lock-free hash table for FEB synchronization

 4. Direct thread swapping, esp. for sinc's or other synchronization operations
    where the next thread to execute is obvious.

 5. Qthreads with in/out vectors for cross-node workstealing

 6. Cross-node work spawning and memory access

 7. Cross-node synchronization

 8. Hierarchical shepherds (need to rename shepherds)

 9. 128-bit syncvars

10. Change the futurelib spawner to use up existing concurrency limits before
    blocking

11. Add a qthread_replace(me, func, arg, argsize) function to enable convenient
    tail-recursion algorithms

12. Make futurelib limits dynamic

13. Further optimize memory pooling (steal ideas from tcmalloc?)

14. Port to XMT (is this even possible???)

15. Rework futures to use preallocated contexts

16. Rework most qutil/qloop functions to deal with deactivated shepherds

17. Continuation passing (start with cross-node migration, with the agreement
    that no pointers will work after a migration)... CAN BE DONE WITH MPI

	- Can allow for qthread_incr/feb/etc operation IFF we can identify them
	  ahead of time, and then keep a lookup table of them that sticks with the
	  thread to identify the "home" so that we can send the necessary messages
	  to make those operations happen on the right "home" node

18. Coalesce system calls

19. Implement MAMA malloc?

Things to think about:

 1. Non-executing shepherds to allow for memory locales without associated
 	computing resources.
