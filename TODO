These are ideas for things to add (in no particular order):

 0. Intercept blocking syscalls

 1. Investigate parallel (mmap-based) I/O

 2. 128-bit syncvars

 3. Change the futurelib spawner to use up existing concurrency limits before
    blocking

 4. Add a qthread_replace(me, func, arg, argsize) function to enable convenient
    tail-recursion algorithms

 5. Add a qthread_forker(func, ret, ...) that accepts multiple arguments. How
    painful would this be?

 6. Make futurelib limits dynamic

 7. Rework qpool strategy

 8. Port to XMT (is this even possible???)

 9. Rework futures to use preallocated contexts

10. Rework futures to use small structs for queueing new futures

11. Rework most qutil/qloop functions to deal with deactivated shepherds

12. Continuation passing (start with cross-node migration, with the agreement
    that no pointers will work after a migration)... CAN BE DONE WITH MPI

	- Can allow for qthread_incr/feb/etc operation IFF we can identify them
	  ahead of time, and then keep a lookup table of them that sticks with the
	  thread to identify the "home" so that we can send the necessary messages
	  to make those operations happen on the right "home" node

Things to think about:

 0. Thread-specific data (perhaps shepherd-specific data?)

 1. Non-executing shepherds to allow for memory locales without associated
 	computing resources.
