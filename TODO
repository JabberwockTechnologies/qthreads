These are ideas for things to add (in no particular order):

 0. Adaptive loops: hierarchical iteration fetching/distribution to avoid
    hot-spotting?

 1. Change the futurelib spawner to use up existing concurrency limits before
    blocking

 2. Add a qthread_replace(me, func, arg, argsize) function to enable convenient
    tail-recursion algorithms

 3. Add a qthread_forker(func, ret, ...) that accepts multiple arguments. How
    painful would this be?

 4. Directed rescheduling, where I specify that I want to prioritize a given
	thread's return value. The easy thing to do is to use a special type of
	fork that creates a "special" return value (i.e. stored in a hash) so that
	I don't have to save EVERY thread for lookup. However, that approach has
	unexpected consequences when a prioritized thread is blocking on an
	unprioritizeable thread...

 5. Make futurelib limits dynamic

 6. Rework qpool strategy

 7. Port to XMT (is this even possible???)

 8. Rework futures to use preallocated contexts

 9. Rework futures to use small structs for queueing new futures

10. Rework most qutil/qloop functions to deal with deactivated shepherds

11. Continuation passing (start with cross-node migration, with the agreement
    that no pointers will work after a migration)... CAN BE DONE WITH MPI

	- Can allow for qthread_incr/feb/etc operation IFF we can identify them
	  ahead of time, and then keep a lookup table of them that sticks with the
	  thread to identify the "home" so that we can send the necessary messages
	  to make those operations happen on the right "home" node

Things to think about:

 0. Thread-specific data (perhaps shepherd-specific data?)

 1. Non-executing shepherds to allow for memory locales without associated
 	computing resources.

 2. Hierarchical shepherds
