.TH qutil_qsort 3 "MAY 2007" libqthread "libqthread"
.SH NAME
\fBqutil_qsort\fR, \fBqutil_mergesort\fR \- sorts an array of doubles in parallel
.SH SYNOPSIS
.B #include <qthread/qthread.h>
.br
.B #include <qthread/qutil.h>

.I void
.br
\fBqutil_qsort\fR(qthread_t *\fIme\fR, double *\fIarray\fR, size_t \fIlength\fR);
.PP
.I void
.br
\fBqutil_mergesort\fR(qthread_t *\fIme\fR, double *\fIarray\fR, size_t
\fIlength\fR);
.SH DESCRIPTION
These functions take as input an \fIarray\fR of \fIlength\fR numbers and sorts their values.
.PP
In \fBqutil_qsort\fR, large amounts of parallelism is achieved by using a strided lagging-loop structure for the partitioning phases of the sort, and a tree structure (with a minimum leaf-size) for the divide-and-conquer phases of the sort. The design is based, partly, upon work done by CRAY for their MTA-threaded quicksort. For sufficiently small arrays or sub-arrays, the libc \fBqsort\fR function is used.
.PP
IN \fBqutil_mergesort\fR, the parallelism is achieved solely from the obvious divide-and-conquer tree. The merge phases of the algorithm use an in-place merge rather than a lookaside merge. As a result, the merge phases are rather computationally intensive. (This sort exists primarily as a proof of concept rather than as a useful alternative.)
.PP
The parallelism in these sorts is NOT limited by the futurelib resource restrictions, because of the divide-and-conquer trees in both. Future implementations may use the futurelib if and when futurelib is reimplemented to allow forward progress without exceeding memory restrictions (significantly) even when there are an extremely large number of futures attempting to spawn new futures.
.PP
The result of the sort is an array in increasing order.
.SH SEE ALSO
.BR qutil_double_sum (3),
.BR qutil_double_mult (3),
.BR qutil_double_min (3),
.BR qutil_double_max (3),
.BR qutil_uint_sum (3),
.BR qutil_uint_mult (3),
.BR qutil_uint_min (3),
.BR qutil_uint_max (3),
.BR qutil_int_sum (3),
.BR qutil_int_mult (3),
.BR qutil_int_min (3),
.BR qutil_int_max (3),
.BR qsort (3)
