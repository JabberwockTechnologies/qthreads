These are ideas for things to do (in no particular order):

 0. Intercept blocking syscalls (solidify, expand)

 1. Qthread teams (for synchronization, e.g. barrier)

 2. Mass thread-kill (e.g. eurekas)

 3. Lock-free hash table for FEB synchronization

 4. Lock-free double-ended queue for Gatling scheduler

 5. Task-local data (runtime configurable static size (similar to stack size));
	share space with argument space, fall back to malloc for exceeding the
	preallocated space

 6. Qthreads with in/out vectors for cross-node workstealing

 7. Cross-node work spawning and memory access

 8. Cross-node synchronization

 9. Hierarchical shepherds (need to rename shepherds)

10. 128-bit syncvars

11. Change the futurelib spawner to use up existing concurrency limits before
    blocking

12. Add a qthread_replace(me, func, arg, argsize) function to enable convenient
    tail-recursion algorithms

13. Add a qthread_forker(func, ret, ...) that accepts multiple arguments. How
    painful would this be?

14. Make futurelib limits dynamic

15. Rework qpool strategy

16. Port to XMT (is this even possible???)

17. Rework futures to use preallocated contexts

18. Rework futures to use small structs for queueing new futures

19. Rework most qutil/qloop functions to deal with deactivated shepherds

20. Continuation passing (start with cross-node migration, with the agreement
    that no pointers will work after a migration)... CAN BE DONE WITH MPI

	- Can allow for qthread_incr/feb/etc operation IFF we can identify them
	  ahead of time, and then keep a lookup table of them that sticks with the
	  thread to identify the "home" so that we can send the necessary messages
	  to make those operations happen on the right "home" node

21. Coalesce system calls

22. Implement MAMA malloc?

Things to think about:

 1. Non-executing shepherds to allow for memory locales without associated
 	computing resources.
